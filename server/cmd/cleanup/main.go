package main

import (
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"ai-conversation-platform/internal/storage/postgres"
)

func main() {
	var dryRun bool
	var deleteAll bool
	flag.BoolVar(&dryRun, "dry-run", false, "Show what would be deleted without actually deleting")
	flag.BoolVar(&deleteAll, "all", false, "Delete ALL conversations and related data")
	flag.Parse()

	client, err := postgres.NewClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to connect to database: %v\n", err)
		os.Exit(1)
	}
	defer client.Close()

	if deleteAll {
		if err := deleteAllConversations(client.DB, client.DBType, dryRun); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to delete all conversations: %v\n", err)
			os.Exit(1)
		}
		if dryRun {
			fmt.Println("\nDry-run completed. Run without -dry-run to perform actual deletion.")
		} else {
			fmt.Println("\nAll conversations and related data deleted successfully!")
		}
		return
	}

	if err := cleanupInvalidMetadata(client.DB, client.DBType, dryRun); err != nil {
		fmt.Fprintf(os.Stderr, "Cleanup failed: %v\n", err)
		os.Exit(1)
	}

	if err := cleanupConversationsWithoutCustomerMessages(client.DB, client.DBType, dryRun); err != nil {
		fmt.Fprintf(os.Stderr, "Cleanup failed: %v\n", err)
		os.Exit(1)
	}

	if dryRun {
		fmt.Println("\nDry-run completed. Run without -dry-run to perform actual cleanup.")
	} else {
		fmt.Println("\nCleanup completed successfully!")
	}
}

// cleanupInvalidMetadata removes conversation_metadata entries for conversations
// that don't have any customer messages (these were incorrectly generated by old code)
func cleanupInvalidMetadata(db *sql.DB, dbType string, dryRun bool) error {
	// Find all conversation_metadata entries for conversations that don't have customer messages
	query := `
		SELECT cm.conversation_id
		FROM conversation_metadata cm
		WHERE NOT EXISTS (
			SELECT 1
			FROM messages m
			WHERE m.conversation_id = cm.conversation_id
			AND m.sender = 'customer'
		)
	`

	rows, err := db.Query(query)
	if err != nil {
		return fmt.Errorf("failed to query invalid metadata: %w", err)
	}
	defer rows.Close()

	var conversationIDs []string
	for rows.Next() {
		var convID string
		if err := rows.Scan(&convID); err != nil {
			return fmt.Errorf("failed to scan conversation ID: %w", err)
		}
		conversationIDs = append(conversationIDs, convID)
	}

	if err = rows.Err(); err != nil {
		return fmt.Errorf("error iterating rows: %w", err)
	}

	if len(conversationIDs) == 0 {
		fmt.Println("No invalid metadata entries found. Database is clean.")
		return nil
	}

	fmt.Printf("Found %d conversation_metadata entries for conversations without customer messages:\n", len(conversationIDs))
	for _, convID := range conversationIDs {
		fmt.Printf("  - %s\n", convID)
	}

	if dryRun {
		return nil
	}

	// Delete the invalid metadata entries
	// Build IN clause - use ? for SQLite, $1, $2, etc. for PostgreSQL
	args := make([]interface{}, len(conversationIDs))
	var placeholders []string
	
	if dbType == "postgres" {
		for i, convID := range conversationIDs {
			placeholders = append(placeholders, fmt.Sprintf("$%d", i+1))
			args[i] = convID
		}
	} else {
		// SQLite uses ? placeholders
		for i, convID := range conversationIDs {
			placeholders = append(placeholders, "?")
			args[i] = convID
		}
	}
	
	deleteQuery := fmt.Sprintf("DELETE FROM conversation_metadata WHERE conversation_id IN (%s)", strings.Join(placeholders, ","))
	result, err := db.Exec(deleteQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete invalid metadata: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Warning: Could not get rows affected count: %v", err)
	} else {
		fmt.Printf("\nDeleted %d invalid metadata entries.\n", rowsAffected)
	}

	return nil
}

// cleanupConversationsWithoutCustomerMessages removes conversations that don't have any customer messages
func cleanupConversationsWithoutCustomerMessages(db *sql.DB, dbType string, dryRun bool) error {
	// Find all conversations that don't have any customer messages
	query := `
		SELECT c.id
		FROM conversations c
		WHERE NOT EXISTS (
			SELECT 1
			FROM messages m
			WHERE m.conversation_id = c.id
			AND m.sender = 'customer'
		)
	`

	rows, err := db.Query(query)
	if err != nil {
		return fmt.Errorf("failed to query conversations without customer messages: %w", err)
	}
	defer rows.Close()

	var conversationIDs []string
	for rows.Next() {
		var convID string
		if err := rows.Scan(&convID); err != nil {
			return fmt.Errorf("failed to scan conversation ID: %w", err)
		}
		conversationIDs = append(conversationIDs, convID)
	}

	if err = rows.Err(); err != nil {
		return fmt.Errorf("error iterating rows: %w", err)
	}

	if len(conversationIDs) == 0 {
		fmt.Println("No conversations without customer messages found.")
		return nil
	}

	fmt.Printf("\nFound %d conversations without customer messages:\n", len(conversationIDs))
	for _, convID := range conversationIDs {
		fmt.Printf("  - %s\n", convID)
	}

	if dryRun {
		fmt.Println("These conversations and their related data (messages, metadata, auto-reply configs) would be deleted.")
		return nil
	}

	// Delete related data first (due to foreign key constraints)
	// Note: conversation_metadata and auto_reply_conversations have CASCADE, but let's be explicit
	
	// Build placeholders for SQL queries
	args := make([]interface{}, len(conversationIDs))
	var placeholders []string
	
	if dbType == "postgres" {
		for i, convID := range conversationIDs {
			placeholders = append(placeholders, fmt.Sprintf("$%d", i+1))
			args[i] = convID
		}
	} else {
		for i, convID := range conversationIDs {
			placeholders = append(placeholders, "?")
			args[i] = convID
		}
	}
	
	// Delete auto_reply_conversations first
	fmt.Println("\nDeleting related auto-reply configurations...")
	deleteAutoReplyQuery := fmt.Sprintf("DELETE FROM auto_reply_conversations WHERE conversation_id IN (%s)", strings.Join(placeholders, ","))
	_, err = db.Exec(deleteAutoReplyQuery, args...)
	if err != nil {
		log.Printf("Warning: Could not delete auto-reply configs (may not exist): %v", err)
	}

	// Delete messages (though CASCADE should handle it)
	fmt.Println("Deleting related messages...")
	
	deleteMessagesQuery := fmt.Sprintf("DELETE FROM messages WHERE conversation_id IN (%s)", strings.Join(placeholders, ","))
	result, err := db.Exec(deleteMessagesQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete messages: %w", err)
	}
	
	messagesDeleted, _ := result.RowsAffected()
	fmt.Printf("Deleted %d messages.\n", messagesDeleted)

	// Delete conversations
	fmt.Println("Deleting conversations...")
	deleteConversationsQuery := fmt.Sprintf("DELETE FROM conversations WHERE id IN (%s)", strings.Join(placeholders, ","))
	result, err = db.Exec(deleteConversationsQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete conversations: %w", err)
	}

	conversationsDeleted, err := result.RowsAffected()
	if err != nil {
		log.Printf("Warning: Could not get rows affected count: %v", err)
	} else {
		fmt.Printf("Deleted %d conversations.\n", conversationsDeleted)
	}

	return nil
}

// deleteAllConversations deletes ALL conversations and related data (messages, metadata)
func deleteAllConversations(db *sql.DB, dbType string, dryRun bool) error {
	var count int
	countQuery := "SELECT COUNT(*) FROM conversations"
	if err := db.QueryRow(countQuery).Scan(&count); err != nil {
		return fmt.Errorf("failed to count conversations: %w", err)
	}

	fmt.Printf("Found %d conversations to delete\n", count)

	if count == 0 {
		fmt.Println("No conversations to delete.")
		return nil
	}

	if dryRun {
		fmt.Printf("DRY RUN: Would delete %d conversations and all related messages/metadata\n", count)
		return nil
	}

	// Delete all conversations (CASCADE will delete related messages and metadata)
	deleteQuery := "DELETE FROM conversations"
	result, err := db.Exec(deleteQuery)
	if err != nil {
		return fmt.Errorf("failed to delete conversations: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	fmt.Printf("Deleted %d conversations and all related data\n", rowsAffected)

	// Also clean up conversation_metadata (in case CASCADE didn't work)
	_, err = db.Exec("DELETE FROM conversation_metadata")
	if err != nil {
		log.Printf("Warning: Failed to delete conversation_metadata: %v\n", err)
	}

	return nil
}
